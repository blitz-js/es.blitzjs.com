---
title: Páginas
sidebar_label: Páginas
---

En Blitz, una **página** es un
[Componente de React](https://es.reactjs.org/docs/components-and-props.html)
exportado desde un archivo `.js`, `.jsx`, `.ts`, o `.tsx` en un directorio
`pages`. Cada página está asociada a una ruta de acuerdo a la ruta del
archivo.

Las siguientes son páginas válidas:

- `app/pages/about.tsx`
- `app/projects/pages/projects/index.tsx`
- `app/tasks/pages/projects/[projectId]/tasks/[taskId].tsx`

**Ejemplo**: Si creas una página `app/pages/about.js`, que exporta un componente
de React, como se muestra, será accesible a través de la ruta `/about`.

```jsx
function About() {
  return <div>About</div>
}

export default About
```

### Páginas con Rutas Dinámicas {#pages-with-dynamic-routes}

Blitz tiene soporte para páginas con rutas dinámicas. Por ejemplo, si creas un
archivo `app/pages/posts/[id].js`, será accesible a través de las rutas
`posts/1`, `posts/2`, etc.

> Para aprender más sobre el enrutamiento, mira la
> [Documentación de Enrutamiento](./routing).

### Optimización Estática Automática {#automatic-static-optimization}

Por defecto, Blitz pre-renderiza el HTML estático para cada página, a menos que
optes explícitamente por el renderizado en el lado del servidor.

Para páginas con datos dinámicos, el estado de carga de _fallback_ de la página
será renderizado, a menos que realices un [_prefetch_](./query-usage#prefetching)
de los datos para popular el caché.

En algunos casos, la optimización estática puede causar una experiencia de
usuario(UX) indeseada, donde el primer renderizado muestra una cosa, pero el
segundo renderizado muestra otra. Esto sucede por ejemplo cuando usas
`useSession()`.

A continuación vamos a introducir algunas maneras de mejorar el modo en que
Blitz pre-renderiza tus páginas estáticas.

### UX del Primer Renderizado {#first-render-ux}

Con el fin de proveer una mejor experiencia de usuario(UX), Blitz
automáticamente intenta pre-renderizar el HTML de tus páginas, pero si tu
página contiene datos dinámicos pedidos con _hooks_ [useQuery](./use-query),
Blitz hará un _fallback_ al estado de carga de la página y no notarás muchos de
los beneficios del pre-renderizado automático, porque la aplicación requerirá
hacer otra solicitud inmediatamente para pedir los datos que necesita para
satisfacier la consulta.

En este caso puedes asignar `Page.suppressFirstRenderFlicker = true`, y Blitz
va a esconder el contenido de la primer renderización. Esto resulta en un leve
retraso al mostrar la página inicialmente, pero mejorará significativamente la
UX percibida.

```tsx
const Page: BlitzPage = () => {
  return <div>{/* ... */}</div>
}

// highlight-start
Page.suppressFirstRenderFlicker = true
// highlight-end

export default Page
```

En caso que hayas asignado `Page.authenticate = true` o
`Page.redirectAuthenticatedTo = true`, Blitz no mostrará el contenido del primer
renderizado. Para estos casos, puedes simplemente ignorar la configuración
`Page.suppressFirstRenderFlicker = true`.

También puedes considerar hacer un _prefetch_ de todas las consultas necesarias
para completar el primer renderizado de tu página. Puedes usar las funciones de
página `getStaticProps` o `getServerSideProps`, dependiendo de tus necesidades.

Si creas una instancia de `QueryClient` y la populas con datos de una consulta,
entonces puedes pasarla como `dehydratedState` a los _props_ de tu página.
Automáticamente Blitz usará el estado para construir el caché de la consulta
cuando la página intente renderizar luego.

```tsx
import {
  useQuery,
  getQueryKey,
  invokeWithMiddleware,
  dehydrate,
  QueryClient,
  BlitzPage,
  GetServerSidePropsContext,
} from "blitz"
const Page: BlitzPage = () => {
  // highlight-start
  const [organization] = useQuery(getCurrentOrganization, null)
  // highlight-end

  return <div>You have selected: {organization.name}</div>
}

export async function getServerSideProps(ctx: GetServerSidePropsContext) {
  const queryClient = new QueryClient()

  // highlight-start
  const queryKey = getQueryKey(getCurrentOrganization, null)
  await queryClient.prefetchQuery(queryKey, () =>
    invokeWithMiddleware(getCurrentOrganization, null, ctx)
  )
  // highlight-end

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}
```

De este modo, la versión pre-renderizada de tu página HTML no tendrá que hacer
un pedido apenas cargue para solicitar los datos y se evita cualquier parpadeo
en la pantalla. Esto es muy útil para la optimización de motores de búsqueda y
los _previews_ de enlaces que utilizan las Redes Sociales como Facebook y
Twitter.

También puedes usar _prefetching_ para pre-popular consultas que un usuario
pueda necesitar cuando la página se muestra--por ejemplo búsquedas comúnes
o criterios de filtros-- configurando un [staleTime](./use-query#options) en la
consulta sobre la cual se realiza el _prefetch_.

### Generación de Páginas Estáticas para Páginas No Autenticadas {#static-page-generation-for-unauthenticated-pages}

Para páginas accesibles por quien sea sin autenticación, recomendamos usar
`getStaticProps` para que la página, junto con sus datos, sea estadísticamente
100% generada durante el pre-renderizado(como Gatsby). Entonces la página
estática completa puede cachearse en un CDN. Esto es perfecto para páginas
públicas como entradas de blogs.

Existen dos métodos para usar generación estática, usualmente usarás ambos
métodos juntos.

1. `getStaticProps` - Para cargar los **datos** para tu página. Mira la
[documentación de `getStaticProps`](./get-static-props) para más detalles.
2. `getStaticPaths` - Para cargar las posibles **rutas** para tu página. Mira la
[documentación de `getStaticPaths`](./get-static-paths) para más detalles.

### Renderizado en el Lado del Servidor {#server-side-rendering}

> También conocido como "SSR" o "Dynamic Rendering"(Renderizado Dinámico).

Si una página usa **Renderizado en el Lado del Servidor**, la página HTML es
generada en **cada solicitud**.

Para usar Renderizado en el Lado del Servidor para una página, debes utilizar
`export` a una función `async` llamada `getServerSideProps`. Esta función será
llamada por el servidor en cada solicitud.

Mira la [documentación de `getServerSideProps`](./get-server-side-props) para
más detalles.
