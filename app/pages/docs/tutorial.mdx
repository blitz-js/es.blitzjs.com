---
title: Tutorial
sidebar_label: Tutorial
---

<<<<<<< HEAD
En este tutorial, crearemos una aplicaciÃ³n de votaciÃ³n bÃ¡sica.

Asumiremos que ya tienes [Blitz instalado](./get-started). Para saber si
lo tienes instalado, ejecuta el siguiente comando en tu terminal:
=======
In this tutorial, weâ€™ll walk you through the creation of a basic voting
application.

Weâ€™ll assume that you have [Blitz installed](./get-started) already. You
can tell if Blitz is installed, and which version you have by running the
following command in your terminal:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```sh
blitz -v
```

<<<<<<< HEAD
Si Blitz estÃ¡ instalado, deberÃ­as ver la versiÃ³n de tu instalaciÃ³n. Y si
no lo tienes, obtendrÃ¡s un error como "comando no encontrado".
=======
If Blitz is installed, you should see the version of your installation. If
it isnâ€™t, youâ€™ll get an error saying something like â€œcommand not found:
blitzâ€.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## Creando una nueva App {#creating-a-new-app}

<<<<<<< HEAD
Desde la terminal, haz `cd` hacia el directorio donde te gustarÃ­a crear tu
aplicaciÃ³n y ejecuta el siguiente comando:
=======
From the command line, `cd` into the folder where youâ€™d like to create
your app, and then run the following command:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```sh
blitz new my-blitz-app
```

<<<<<<< HEAD
Blitz crearÃ¡ un directorio llamado `my-blitz-app` en tu directorio actual.
Se te harÃ¡ elegir una librerÃ­a para hacer formularios. Para este tutorial,
selecciona la librerÃ­a recomendada: _React Final Form_.

Veamos que creÃ³ `blitz new`:
=======
Blitz will create a `my-blitz-app` folder in your current folder. You will
be prompted to pick a form library. For this tutorial, select the
recommended library `React Final Form`.

Letâ€™s look at what `blitz new` created:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```
my-blitz-app
â”œâ”€â”€ app/
â”‚Â Â  â”œâ”€â”€ api/
â”‚Â Â  â”œâ”€â”€ auth/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LoginForm.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SignupForm.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mutations/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ changePassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logout.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgot-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ reset-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ validations.ts
â”‚Â Â  â”œâ”€â”€ core/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Form.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ LabeledTextField.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useCurrentUser.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ layouts/
â”‚Â Â  â”‚Â Â      â””â”€â”€ Layout.tsx
â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 404.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _app.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _document.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.test.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â””â”€â”€ users/
â”‚Â Â      â””â”€â”€ queries/
â”‚Â Â          â””â”€â”€ getCurrentUser.ts
â”œâ”€â”€ db/
â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ schema.prisma
â”‚Â Â  â””â”€â”€ seeds.ts
â”œâ”€â”€ integrations/
â”œâ”€â”€ mailers/
â”‚Â Â  â””â”€â”€ forgotPasswordMailer.ts
â”œâ”€â”€ public/
â”‚Â Â  â”œâ”€â”€ favicon.ico*
â”‚Â Â  â””â”€â”€ logo.png
â”œâ”€â”€ test/
â”‚Â Â  â”œâ”€â”€ setup.ts
â”‚Â Â  â””â”€â”€ utils.tsx
â”œâ”€â”€ README.md
â”œâ”€â”€ babel.config.js
â”œâ”€â”€ blitz.config.js
â”œâ”€â”€ jest.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ types.d.ts
â”œâ”€â”€ types.ts
â””â”€â”€ yarn.lock
```

Estos archivos son:

<<<<<<< HEAD
- La carpeta `app/` es un contenedor para la mayor parte de tu proyecto.
  AllÃ­ es donde pondrÃ¡s tus pÃ¡ginas y tus rutas API.

- La carpeta `app/pages/` es la carpeta primaria para guardar pÃ¡ginas. Si
  has usado Next.js, inmediatamente notarÃ¡s que es diferente. En Blitz,
  puedes tener varias carpetas `pages` que serÃ¡n fusionadas al compilar.

- La carpeta `app/core/` es el lugar principal para poner tus componentes,
  hooks, etcÃ©tera que se utilizan a lo largo de tu aplicaciÃ³n.

- `db/` es donde la configuraciÃ³n de tu base de datos se aloja. Si
  escribes modelos o manejas migraciones, este es el lugar donde ponerlo.

- En `public/` van todos tus archivos estÃ¡ticos. Si tienes imÃ¡genes,
  fotos, videos, u otros archivos, van adentro de `public/`.

- `.babelrc.js`, `.env`, etc. ("dotfiles") son archivos de configuraciÃ³n
  para varias herramientas utilizadas dentro de la aplicaciÃ³n.

- `blitz.config.js` es para personalizar Blitz (avanzado). Tiene el mismo
  formato que `next.config.js`.
=======
- The `app/` folder is a container for most of your project. This is where
  youâ€™ll put any pages or API routes.

- The `app/pages/` folder is the primary pages folder. If you've used
  Next.js you'll immediately notice this is different. In Blitz, you can
  have many `pages` folders and they will be merged together at build
  time.

- The `app/core/` folder is the main place to put components, hooks, etc
  that are used throughout your app.

- `db/` is where your database configuration goes. If youâ€™re writing
  models or checking migrations, this is where to go.

- `public/` is a folder where you will put any static assets. If you have
  images, files, or videos which you want to use in your app, this is
  where to put them.

- `.babelrc.js`, `.env`, etc. ("dotfiles") are configuration files for
  various bits of JavaScript tooling.

- `blitz.config.js` is for advanced custom configuration of Blitz. It's
  the same format as `next.config.js`.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

- `tsconfig.json` es nuestra configuraciÃ³n recomendada para TypeScript.

## El servidor de desarrollo {#the-development-server}

<<<<<<< HEAD
Ahora, asegÃºrate de estÃ¡s dentro del directorio `my-blitz-app` y ejecuta
el siguiente comando:
=======
Now make sure you are in the `my-blitz-app` folder, if you havenâ€™t
already, and run the following command:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```sh
blitz dev
```

VerÃ¡s lo siguiente en la terminal:

```sh
âœ” Compiled
Loaded env from /private/tmp/my-blitz-app/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /my-blitz-app/babel.config.js
event - compiled successfully
```

<<<<<<< HEAD
Eso significa que el servidor de desarrollo se estÃ¡ ejecutando. Ve a
[localhost:3000](http://localhost:3000) en tu navegador. Si ves una pÃ¡gina
de bienvenida con el logo de Blitz, Â¡funcionÃ³!
=======
Now that the serverâ€™s running, visit
[localhost:3000](http://localhost:3000) with your web browser. Youâ€™ll see
a welcome page, with the Blitz logo. It worked!
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## Registrarse como un usuario {#sign-up-as-a-user}

<<<<<<< HEAD
Las aplicaciones Blitz son creadas con registros e inicios de sesiÃ³n ya
integrados. Vamos a probarlos. Haz click en **Sign Up**. Pon un email y
una contraseÃ±a cualquiera y presiona **Create Account**. Luego, serÃ¡s
redirigido de vuelta al inicio, donde verÃ¡s el `id` y el `role` de tu
usuario.

Si quieres, puedes probar a cerrar la sesiÃ³n, volver a iniciarla, e
incluso hacer click en **Forgot your password?** y ver cÃ³mo funciona.
=======
Blitz apps are created with user signup and login already set up! So let's
try it. Click on the **Sign Up** button. Enter any email and password and
click **Create Account**. Then you'll be redirected back to the home page
where you can see your user `id` and `role`.

If you want, you can also try logging out and logging back in. Or click
**Forgot your password?** on the login page to try that flow.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## Escribe tu primera pÃ¡gina {#write-your-first-page}

Vamos a crear tu primera pÃ¡gina.

<<<<<<< HEAD
Abre el archivo `app/pages/index.tsx` y reemplaza los contenidos del
componente `Home` por lo siguiente:
=======
Open the file `app/pages/index.tsx` and replace the contents of the `Home`
component with this:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Â¡Hola, Mundo!</h1>

      <Suspense fallback="Cargando...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

<<<<<<< HEAD
Guarda el archivo y verÃ¡s la pÃ¡gina actualizarse en tu navegador. Puedes
personalizar esto cuanto quieras. Cuando estÃ©s listo, continÃºa hacia la
siguiente secciÃ³n.
=======
Save the file and you should see the page update in your browser. You can
add customize this as much as you want. When youâ€™re ready, move on to the
next section.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## PreparaciÃ³n de la Base de Datos {#database-setup}

<<<<<<< HEAD
Â¡Excelentes noticias, una base de datos SQLite ya ha sido creada para ti!
Puedes ejecutar `blitz prisma studio` en la terminal y verÃ¡s una interfaz
web en la que podrÃ¡s ver los datos de tu base de datos.

Ten en cuenta que cuando comiences un proyecto real, es posible que
necesites una base de datos mÃ¡s escalable, como PostgreSQL, para evitar
cambiar de base de datos en la mitad de tu proyecto. Para mÃ¡s informaciÃ³n,
lee [Sobre las Bases de Datos](database-overview). Por ahora,
continuaremos con SQLite.
=======
Good news, an SQLite database was already set up for you! You can run
`blitz prisma studio` in the terminal to open a web interface where you
can see the data in your database.

Note that when starting your first real project, you may want to use a
more scalable database like PostgreSQL, to avoid the pains of switching
your database down the road. For more information, see
[Database overview](database-overview). For now, we will continue with the
default SQLite database.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## CÃ³digo base para nuestros modelos {#scaffolding-code-for-our-models}

<<<<<<< HEAD
Blitz provee un comando muy Ãºtil llamado [`generate`](cli-generate) para
crear cÃ³digo base, que luego ajustaremos a nuestras necesidades. Usaremos
`generate` para crear dos modelos: `Question` y `Choice`. Una `Question`
tiene el texto de la pregunta y una lista de opciones. Una `Choice` tiene
el texto de la opciÃ³n, un contador de votos y una pregunta asociada. Blitz
generarÃ¡ un ID, una campo `createdAt` y uno `updatedAt` a cada modelo
automÃ¡ticamente.
=======
Blitz provides a handy CLI command called [`generate`](./cli-generate) for
scaffolding out boilerplate code. We'll use `generate` to create two
models: `Question` and `Choice`. A `Question` has the text of the question
and a list of choices. A `Choice` has the text of the choice, a vote
count, and an associated question. Blitz will automatically generate an
id, a creation timestamp, and a last updated timestamp for both models.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

#### Primero, generaremos todo lo relacionado con el modelo `Question`:

```sh
blitz generate all question text:string
```

<<<<<<< HEAD
Y cuando te lo pregunten, presiona **Enter** para ejecutar
`prisma migrate` y actualizar el esquema de tu base de datos. Te
preguntarÃ¡ por un nombre para la migraciÃ³n; pon algo como "question
creada".
=======
And when prompted, press the **Enter** to run `prisma migrate` which will
update your database schema with the new model. It will ask for a name, so
type something like "add question".
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

âœ” Model for 'question' created in schema.prisma:

> model Question {
>   id        Int      @default(autoincrement()) @id
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }

? Run 'prisma migrate dev' to update your database? (Y/n) â€º true
```

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

âœ” Name of migration â€¦ add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20210217035805_add_question/
    â””â”€ migration.sql

âœ” Generated Prisma Client (2.17.0) to ./node_modules/@prisma/client in 103ms

Everything is now in sync.
```

<<<<<<< HEAD
El comando `generate` con el tipo `all` genera un modelo y sus respectivas
consultas (o _queries_), mutaciones y pÃ¡ginas. En la pÃ¡gina de
[`blitz generate`](./cli-generate) hay una lista de todas las opciones
disponibles.

#### Ahora generaremos el modelo `Choice` con sus consultas y mutaciones correspondientes.

Esta vez le pasaremos el tipo `resource`, ya que no necesitamos generar
pÃ¡ginas para el modelo `Choice`:
=======
The `generate` command with a type of `all` generates a model and queries,
mutation and page files. See the [Blitz generate](./cli-generate) page for
a list of available type options.

#### Next we'll generate the `Choice` model with corresponding queries and mutations.

We'll pass a type of `resource` this time as we don't need to generate
pages for the `Choice` model:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

<<<<<<< HEAD
Presiona **Enter** cuando te lo pidan para ejecutar la migraciÃ³n. No te
olvides de ponerle un nombre.
=======
Again, hit **Enter** when prompted to run the migration and enter a name
for the migration.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

âœ” Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) â€º true
```

<<<<<<< HEAD
#### Por Ãºltimo, actualicemos el model `Question` para que estÃ© relacionado a `Choice`.

Abre el archivo `db/schema.prisma` y aÃ±ade `choices Choice[]` al modelo
`Question`.
=======
#### Lastly let's update the `Question` model to have a relationship back to `Choice`.

Open `db/schema.prisma` and add `choices Choice[]` to the `Question`
model.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

<<<<<<< HEAD
Y luego, ejecuta `blitz prisma generate` para actualizar el cliente de
Prisma con los Ãºltimos cambios. Esto no requiere una migraciÃ³n de la base
de datos porque ningÃºn campo se ha aÃ±adido al model `Question` dentro de
la base de datos.
=======
And then run `blitz prisma generate` to update prisma client for that
schema change. This doesn't require a database migration because there's
not an actual field being added to the `Question` model in the database.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## Jugando con el cliente de Prisma {#playing-with-the-prisma-database-client}

<<<<<<< HEAD
Entremos a la terminal interactiva de Blitz y veamos quÃ© podemos hacer con
Prisma, el cliente por defecto que Blitz nos brinda. Para abrir la
terminal, ejecuta este comando:
=======
Now, letâ€™s hop into the interactive Blitz shell and play around with the
Prisma database client that Blitz gives you. To start the Blitz console,
use this command:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```sh
blitz console
```

Ya dentro, explora el cliente de la base de datos:

```sh
# AÃºn no hay preguntas en el sistema.
âš¡ > await db.question.findMany()
[]

# Crea una nueva pregunta
âš¡ > let q = await db.question.create({data: {text: "What's new?"}})
undefined

# Mira el objeto completo
âš¡ > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "What's new?"
}

# O accede una propiedad especÃ­fica
âš¡ > q.text
"What's new?"

# Cambia los valores utilizando la funciÃ³n `update`
âš¡ > q = await db.question.update({where: {id: 1}, data: {text: "What's up?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "What's up?"
}

# `db.question.findMany()` muestra todas las preguntas en la base de datos:
âš¡ > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "What's up?"
  }
]
```

## Actualizar el cÃ³digo generado para nuestras necesidades {#update-generated-code-for-our-model-attributes}

<!-- prettier-ignore-start -->
:::info
<<<<<<< HEAD
Antes de ejecutar nuestra app de nuevo, necesitamos modificar ciertas
partes del cÃ³digo que ha sido generado. Al final, estos cambios no serÃ¡n
necesarios, pero por ahora, necesitamos tratar un par de cuestiones
pendientes.
:::
<!-- prettier-ignore-end -->

El contenido de la pÃ¡gina generado no contiene los atributos que
definimos. Pronto lo harÃ¡, pero mientras tanto, vamos a arreglar las
pÃ¡ginas generadas.

### PÃ¡gina de `Question` {#question-pages}

=======
Before running the app again, we need to customize some of the
code that has been generated. Ultimately, these fixes will not be needed -
but for now, we need to work around a couple outstanding issues.
:::
<!-- prettier-ignore-end -->

The generated page content does not currently use the actual model
attributes you defined during generation. It will soon, but in the
meantime, let's fix the generated pages.

### Question pages {#question-pages}

>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325
[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

<<<<<<< HEAD
Ve a `app/pages/questions/index.tsx`. VerÃ¡s un componente `QuestionsList`:
=======
Jump over to `app/pages/questions/index.tsx`. Notice that a
`QuestionsList` component has been generated for you:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}] = usePaginatedQuery(getQuestions, {
    orderBy: {id: "asc"},
    skip: ITEMS_PER_PAGE * page,
    take: ITEMS_PER_PAGE,
  })

  const goToPreviousPage = () => router.push({query: {page: page - 1}})
  const goToNextPage = () => router.push({query: {page: page + 1}})

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={!hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

<<<<<<< HEAD
Â¡Pero esto no funcionarÃ¡! Recuerda que el modelo `Question` que creamos no
tiene un campo `name`. Para arreglar esto, cambia `question.name` con
`question.text`:
=======
This wonâ€™t work though! Remember that the `Question` model we created
above doesnâ€™t have any `name` field. To fix this, replace `question.name`
with `question.text`:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}] = usePaginatedQuery(getQuestions, {
    orderBy: {id: "asc"},
    skip: ITEMS_PER_PAGE * page,
    take: ITEMS_PER_PAGE,
  })

  const goToPreviousPage = () => router.push({query: {page: page - 1}})
  const goToNextPage = () => router.push({query: {page: page + 1}})

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={!hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

<<<<<<< HEAD
Ahora, vamos a hacer los mismo con
`app/questions/components/QuestionForm.tsx`. En el formulario, reemplaza
`LabeledTextField` `name` por `"text"`
=======
Next, letâ€™s apply a similar fix to
`app/questions/components/QuestionForm.tsx`. In the form submission,
replace the `LabeledTextField` `name` to be `"text"`
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Text" placeholder="Text" />
    </Form>
  )
}
```

### MutaciÃ³n `createQuestion` {#create-question-mutation}

<<<<<<< HEAD
En `app/questions/mutations/createQuestion.ts`, necesitamos actualizar el
esquema de Zod `CreateQuestion` para que use `text` en vez de `name`.
=======
In `app/questions/mutations/createQuestion.ts`, we need to update the
`CreateQuestion` zod validation schema to use `text` instead of `name`.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### MutaciÃ³n `updateQuestion` {#update-question-mutation}

<<<<<<< HEAD
En `app/questions/mutations/updateQuestion.ts`, necesitamos actualizar el
esquema de Zod `UpdateQuestion` para que use `text` en vez de `name`.
=======
In `app/questions/mutations/updateQuestion.ts`, we need to update the
`UpdateQuestion` zod validation schema to use `text` instead of `name`.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

<<<<<<< HEAD
### MutaciÃ³n `deleteQuestion` {#delete-question-mutation}

[//]:
  #
  "Remove this section once Prisma supports cascading deletes. Follow prisma issue #2810"

Por el momento, Prisma no soporta la "eliminaciÃ³n en cascada". En el
contexto de este tutorial, significa que las `Choice` no se borrar
automÃ¡ticamente al borrar una `Question`. Necesitamos modificar
`deleteQuestion` temporalmente para solucionar esto. Abre
`app/questions/mutations/deleteQuestions.ts` y aÃ±ade lo siguiente justo
por encima de `db.question.deleteMany()`:
=======
### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```ts
await db.choice.deleteMany({where: {questionId: id}})
```

<<<<<<< HEAD
DeberÃ­a quedar lo siguiente:
=======
The end result should be as such:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

<<<<<<< HEAD
Esta mutaciÃ³n eliminarÃ¡ las opciones asociadas a la pregunta justo antes
de borrar la pregunta en cuestiÃ³n.
=======
This mutation will now delete the choices associated with the question
prior to deleting the question itself.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

#### Ahora prueba a crear, actualizar y borrar preguntas

<<<<<<< HEAD
Â¡IncreÃ­ble! Ahora ejecuta tu aplicaciÃ³n. Para ejecutarla, escribe
`blitz dev` en tu terminal, presiona Enter y ve a
`localhost:3000/questions`. Prueba creando preguntas, editÃ¡ndolas y
eliminÃ¡ndolas.
=======
Great! Now make sure your app is running. If it isnâ€™t, run `blitz dev` in
your terminal, and visit `localhost:3000/questions`. Try creating
questions, editing, and deleting them.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## Agregando opciones al formulario de las preguntas {#adding-choices-to-the-question-form}

<<<<<<< HEAD
Â¡Lo estÃ¡s haciendo genial! Lo siguiente que haremos serÃ¡ aÃ±adir opciones a
el formulario de las preguntas. Abre
`app/questions/components/QuestionForm.tsx` en tu editor de texto.
=======
Youâ€™re doing great so far! The next thing weâ€™ll do is add choices to our
question form. Open `app/questions/components/QuestionForm.tsx` in your
editor.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

AÃ±ade tres componentes `<LabeledTextField>` mÃ¡s como opciones.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Text" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Choice 1" />
+     <LabeledTextField name="choices.1.text" label="Choice 2" />
+     <LabeledTextField name="choices.2.text" label="Choice 3" />
    </Form>
  )
}
```

<<<<<<< HEAD
Ahora abre `app/pages/questions/new.tsx` y pon a `initialValues` este
valor:
=======
Next open `app/pages/questions/new.tsx` and set `initialValues` to be as
follows:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

<<<<<<< HEAD
Abre `app/questions/mutations/createQuestion.ts` y actualiza el esquema de
Zod para que acepte las opciones en la mutaciÃ³n. AdemÃ¡s, necesitamos
actualizar la llamada a `db.question.create` para que cree las opciones.
=======
Then open `app/questions/mutations/createQuestion.ts` and update the zod
schema so that the choice data is accepted in the mutation. And we also
need to update the `db.question.create` call so that the choices will also
be created.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### PruÃ©balo

<<<<<<< HEAD
Ahora puedes ir a `localhost:3000/questions/new` y crear una nueva
pregunta con opciones.

## Listar las opciones {#listing-choices}
=======
Now you can go to `localhost:3000/questions/new` and create a new question
with choices!
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

Es momento de algo facilito. Vuelve a `localhost:3000/questions` en tu
navegador y mira todas las preguntas que has creado. Â¿QuÃ© te parece si
mostramos las opciones junto a las preguntas? Primero, necesitamos
modificar la consulta de las preguntas. En Prisma, necesitas especificarle
manualmente que quieres recibir objetos relacionados. Cambia tu
`getQuestion.ts` y `getQuestions.ts` para que se vean asÃ­:

<<<<<<< HEAD
=======
Time for a breather. Go back to `localhost:3000/questions` in your browser
and look at all the questions youâ€˜ve created. How about we list these
questionsâ€™ choices here too? First, we need to customize the question
queries. In Prisma, you need to manually let the client know that you want
to query for nested relations. Change your `getQuestion.ts` and
`getQuestions.ts` files to look like this:

>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325
```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

<<<<<<< HEAD
Ahora vuelve a nuestra pÃ¡gina principal de preguntas
(`app/pages/questions/index.tsx`) con tu editor para listar las opciones
de cada pregunta. AÃ±ade este cÃ³digo debajo de `Link` en nuestra
`QuestionList`:
=======
Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Ahora ve a `/questions` en tu navegador. **Â¡Magia!**

## Hagamos un Ãºltimo cambio: Â¡dejemos que la gente vote las preguntas! {#let-people-vote-on-questions}

<<<<<<< HEAD
Abre `app/pages/questions/[questionId].tsx` en tu editor. Primero, vamos a
mejorar esta pÃ¡gina un poquito.

1. Reemplaza `<h1>Question {question.id}</h1>` por
   `<h1>{question.text}</h1>`.

2. Borra el elemento `pre` y copia la lista de opciones que escribimos
   anteriormente:
=======
Open `app/pages/questions/[questionId].tsx` in your editor. First, weâ€™re
going to improve this page somewhat.

1. Replace `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Delete the `pre` element, and copy in our choices list which we wrote
   before:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

<<<<<<< HEAD
Si miras tu navegador, tu pÃ¡gina deberÃ­a verse similar a esto:
=======
If you go back to your browser, your page should now look something like
this!
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

<<<<<<< HEAD
#### Â¡Vamos a aÃ±adir votaciones!

Primero, necesitamos abrir `app/choices/mutations/updateChoice.ts`,
actualizar el esquema de Zod, y aÃ±adir un incrementador a los votos.
=======
#### Now itâ€™s time to add voting!

First we need to open `app/choices/mutations/updateChoice.ts`, update the
zod schema, and add add a vote increment.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

<<<<<<< HEAD
De nuevo a `app/pages/questions/[questionId].tsx`. Haz los siguientes
cambios:
=======
Now go back to `app/pages/questions/[questionId].tsx` and make the
following changes:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

En nuestro `li`, aÃ±ade un `button` de este modo:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

<<<<<<< HEAD
Importa la mutaciÃ³n `updateChoice` que actualizamos y crea una funciÃ³n
`handleVote` en nuestra pÃ¡gina:
=======
Then, import the `updateChoice` mutation we updated and create a
`handleVote` function in our page:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

<<<<<<< HEAD
Luego necesitamos actualizar la llamada a `useQuery` para que retorne la
funciÃ³n `refetch`. Esta nos servirÃ¡ para actualizar el contador cuando
presionemos _Votar_, asÃ­ que tendremos que llamarla dentro de
`handleVote`.
=======
And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finalmente, tenemos que decirle a nuestro `button` que llame a
`handleVote`.

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

El componente `Question` deberÃ­a verse asÃ­:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({id})
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({id: question.id})
              router.push("/questions")
            }
          }}
          style={{marginLeft: "0.5rem"}}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Finalmente, permitamos editar las opciones {#edit-choices-for-question}

<<<<<<< HEAD
Si haces click en el botÃ³n **Edit** en una de tus preguntas, verÃ¡s que se
utiliza el mismo formulario que al crear una pregunta. Â¡AsÃ­ que eso ya
estÃ¡ hecho! Solo necesitamos modificar nuestra mutaciÃ³n.

Abre `app/questions/mutations/updateQuestion.ts` y haz los siguientes
cambios:
=======
If you click the **Edit** button on one of your existing questions, you'll
see it uses the same form as creating questions. So that part is already
done! We only need to update our mutation.

Open `app/questions/mutations/updateQuestion.ts` and make the following
changes:
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}).nonstrict(),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
<<<<<<< HEAD
+           // Ponemos `|| 0` debido a un bug de Prisma
=======
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
<<<<<<< HEAD
es una operaciÃ³n especial, equivalente a "si este objeto existe, entonces
acutalÃ­zalo; de lo contrario, crÃ©alo". Es perfecto para nuestro caso
porque no le exigimos al usuario crear tres opciones desde un principio.
Por ende, si el usuario aÃ±ane otra opciÃ³n al editar la pregunta,
simplemente se crearÃ¡.
=======
is a special operation that means, "If this item exists, update it. Else
create it". This is perfect for this case because we didn't require the
user to add three choices when creating the question. So if later the user
adds another choice by editing the question, then it'll be created here.
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325

## ConclusiÃ³n {#conclusion}

<<<<<<< HEAD
ðŸ¥³ Â¡Felicidades! Has creado tu primera app con Blitz. DiviÃ©rtete jugando
con ella, o compartÃ­endosela a tus amigos. Ahora que has concluido este
tutorial, Â¿por quÃ© no intentas mejorar tu app aÃºn mÃ¡s? Puedes probar:

- AÃ±adiendo estilos (Pista, prueba `blitz install tailwind` o
  `blitz install chakra-ui`)
- Mostrando mÃ¡s estadÃ­sticas sobre tus votos
- Subir tu app a [Render](./deploy-render) o [Vercel](./deploy-vercel)
  para que el mundo entero pueda utilizarla

Si quieres compartir tu proyecto con la comunidad de Blitz, no hay mejor
lugar que Discord.

Visita [discord.blitzjs.com](https://discord.blitzjs.com). Â¡Comparte el
link en el canal **#built-with-blitz** para que todos puedan verla!
=======
ðŸ¥³ Congrats! You created your very own Blitz app! Have fun playing around
with it, or sharing it with your friends. Now that youâ€™ve finished this
tutorial, why not try making your voting app even better? You could try:

- Adding styling (Hint, try `blitz install tailwind` or
  `blitz install chakra-ui`)
- Showing some more statistics about votes
- Deploying live on [Render](./deploy-render) or [Vercel](./deploy-vercel)

If you want to share your project with the world wide Blitz community
there is no better place to do that than on Discord.

Visit [discord.blitzjs.com](https://discord.blitzjs.com). Then, post the
link to the **#built-with-blitz** channel to share it with everyone!
>>>>>>> 428b3a15308151a36de3968009b7d47be0be3325
